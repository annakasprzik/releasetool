# -*- coding: utf-8 -*-
#
#    releasetool - quality assessment for automatic subject indexing
#    Copyright (C) 2018 Martin Toepfer <m.toepfer@zbw.eu> | ZBW -- Leibniz Information Centre for Economics
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
"""

@author: Martin Toepfer, 2018
"""

from django.core.management.base import BaseCommand, CommandError
from django.utils import timezone as tz
from django.db.utils import OperationalError

from zaptain_rt_app.models import RtConfig, Document, SubjectIndexer, Collection

# see:
# https://docs.djangoproject.com/en/2.0/howto/custom-management-commands/

class Command(BaseCommand):
    help = 'Import subject assignments generated by an automatic method.'
    
    def add_arguments(self, parser):
        av_indexer = SubjectIndexer.objects.exclude(ai_name='').values_list('ai_name', flat=True)
        parser.add_argument('--indexer', help="the ID of the indexer", required=True) # , choices=av_indexer)
        parser.add_argument('--concept_template', help="str.format template with concept id as name cid", default='{cid}')
        parser.add_argument('--limit', help="import at most $limit documents", default=-1, type=int)
        parser.add_argument('--create_emptydoc', help="wheter to create empty documents for illegal references", action="store_true")
        parser.add_argument('--skip_docfail', help="wheter to skip illegal document references", action="store_true")
        parser.add_argument('--create_indexer', help="wheter to create the indexer if does not exist already", action="store_true")
        parser.add_argument('--collection', help="create a corresponding collection with the given name", default=None)
        parser.add_argument('file', nargs=1, help="file format for each line, cells separated by tabs: documentid, concept id1, concept id2, ...") # '+'
    
    def handle(self, *args, **options):
        indexernm = options['indexer']
        colnm = options['collection']
        if not colnm is None:
            collection = Collection.objects.create(name=colnm, description='')
        #
        parse_cell = lambda cell: (cell if ':' in cell else cell + ':1.0').split(':') 
        _ctmplt = options['concept_template']
        try:
            indexer = SubjectIndexer.objects.get(ai_name=indexernm)
        except SubjectIndexer.DoesNotExist as err:
            if options['create_indexer']:
                indexer = SubjectIndexer.objects.create(ai_name=indexernm)
            else:
                raise err
        for fn in options['file']:
            # TODO bulk_create..._toadd = list()
            with open(fn, 'r') as fin:
                for lni, ln in enumerate(fin):
                    _cells = ln.strip().split('\t')
                    docid = _cells[0]
                    doc = None
                    try:
                        doc = Document.objects.get(external_id=docid)
                    except Document.DoesNotExist as err:
                        if options['create_emptydoc']:
                            doc = Document.objects.create(external_id=docid, title='-')
                        else:
                            if options['skip_docfail']:
                                pass
                                # self.stderr.write("illegal document reference to %s" % (str(docid,)))
                            else:
                                raise err
                    if not doc is None:
                        crefs = dict((_ctmplt.format(cid=cid), float(score)) for cid, score in map(parse_cell, _cells[1:]))
                        indexer.assign_scored(doc, crefs)
                        if not colnm is None:
                            collection.documents.add(doc) # _imports.append(doc)
                        if options['limit'] > -1 and lni >= options['limit']:
                            break
        self.stdout.write(self.style.SUCCESS('Successfully imported subject assignments.'))

#            if fn.enswith(''):
#                pass
#            else:
#                self.stdout.write('warning: unhandled file type, @ file ' + str(fn))
        